\chapter{Data acquisition and structure}\label{dataacc}
%
%Before implementing and testing any group creation algorithms, we need to gather usable data
%to perform testing on. The data consists of the topology size, and where in the topology a node is located.
%
%For basic testing we can create our own data, and either assume the location of nodes, or randomly distribute them on a topology.

We don't have the time nor the resources to organize a large enough testbed to purposefully evaluate the algorithms and suggestions that we will look at in the 
consecutive chapters. A sufficient testbed would require a large amount of routers (100-200 for a low scale test) in a small geographical area, preferably installed in 
residential apartment buildings. Not only would the creation of such a testbed require a lot of physical equipment, but there is also a lot of logical challenges 
that would have to be overcome, such as communication protocols and distributed consensus. These are problems we will address at a later point. Additionally, 
we could argue that it never advisable to go directly from an idea to a testbed anyway, especially without having any empirical indication of which approaches have merit,
and which is not worth the effort to implement. The risk is to waste a lot of time and resources to create a real life implementation that could have been identified as pointless 
in an early calculation or simulation. 

In this chapter we will consider how we can develop a tool that generates and visualizes the layout of network topologies based on constructed, artificial data, or
real-life location data of access points. 

\section{Requirements}
SSID, current channel frequency, radio power, physical data rate and supported 802.11 standards are just a few properties of a single real-life access point.
We are going to represent such access points in our network topology, but the access points we are representing will not be in the transmission (CSMA/CA) state where
most of theese properties are used. Our access points are in a state we can call the \textit{group discovery state}, where the goal is to find or create a group to be a part of
so that a channel can be assigned before transmission happens. Hence, to perform our computations, we don't have to consider many of these properties.
Actually, we will only store each access point's SSID, because this is a practical way to uniquely identify them \footnote{In the real world this is of course not the case,
but we will enforce it in our computations. We could just as well call it a unique id.},  and the the list of other access points that can be seen through a WLAN scan with
and their observed signal strength. These are the only metrics we require, but unfortunately there is no publicly available data source that contains the subjective radio scans
of a large amount of access points in the same area.

As a basis for our simulation we will represent nodes on a two-dimensional grid. Each dataset has to contain a set of nodes with two coordinates $x$ and $y$ so they can
positioned on the grid. When the nodes are placed on the grid they represent a network topology
and it will be possible to compute an estimation of which nodes can hear each other on the radio, and add these to each node's SSID-scan list.
This list contains the names of all the nodes it can hear, and how loud it is heard measured in $-dBi$.
Additionally the following parameters should be variable depending on each test scenario:

\begin{itemize}
	\item Topology size with the possibility to give variable width of x- and y-axis as input arguments. These unit of the axes is meters.
	\item Number of nodes to place on the topology
	\item Minimum distance between nodes (in meters). This is only to avoid unlikely placement and extreme interference of nodes that are placed on top of each other. 
	\item Minimum loudness measured in $-dBi$ for a node to account another node as a neighbour (e.g -100 is too low for anyone to hear).
\end{itemize}


	\section{Program design}
	The topology generation program consists of two main functionalitites.

	The first functionality is creating a topology and generate nodes which are uniformly
	and randomly positioned on the network topology. The size of the topology, the number of nodes and the minimum distance
	between nodes are properties that are passed as input arguments to the program.

	The second functionality is performing the calculation of which nodes can actually hear each other over the radio.
	We are assuming all nodes	are transmitting with equal strength, and that the environment is flat and obstacle free. 
	All the neighbouring nodes that can be heard by a node, is added to its list of neighbours, and it stores the $-dBi$ value so it later can be shared with
	the group. The interference levels between access points are calculated by iterating through every access point. For each node $N$ we record its x and y position,
	and then start a second iteration through the nodes. For each node $n$ in the second iteration we calculate the distance $d$ in
	meters between $N$ and $n$ using Euclidean distance. The formula for isotropic antennas is described by Friis \cite{Friis46}, and can be used to
	derive the formula for free space path loss \cite{FSPL} that is as follows:
\[
	FSPL(dB) = 10\log_{10} \left( \frac{ (4 \pi f d)}{c} ^2 \right) 
\]	
	Where $d = distance$, $f = frequency$ and $c=constant$. The constant $c$ is used to account for different units. We will use the meters to denominate the distance,
	and megahertz for the frequency. The resulting formula which will be implemented in the program is
\[
	FSPL(dB) = 20\log_{10}\left( f \right)  + 20\log_{10} \left(d\right) - 27.55
\]	
	As we have to compute the distance from all nodes to every other node, the topology generation program has $O(n^2)$ complexity. A simplified version of the code
	can be seen in figure \ref{fig:dbiCreation}. 

	The resulting program, written in Python 3\cite{Python3}, contains an importable \textit{topology class}. This way, for further testing we can use different data
	sources to get the positions of nodes, and only let the topology class compute the list of neighbours. 
	

	\begin{figure}[H]
	\begin{python}
#In topology class
def measureInterference(self):
 for nodeSubject in self._nodes:  
  for nodeObject in self._nodes:
    nodeSubject.calculateInterferenceTo(nodeObject) 

#In node class
def calculateInterferenceTo(self, nodeObject):
 if self == nodeObject:
  return
 dist = round(self.distanceTo(nodeObject))

#If  nodes have same coordinate, set high interference. 
 if (dist == 0):
  dBi = -40
 else:
  dBi  = self.measureDbi(dist) * -1

def measureDbi(self, dist):
 return (20 * math.log(self._frequency, 10)) + 
(20 * math.log(dist, 10)) - 27.55

			\end{python}
			\caption{Computing the interference between nodes}
			\label{fig:dbiCreation}
			\end{figure}

			\section{Data output and visual representation} \label{simulationrep}
			The result of the topology generation is stored in a JSON\cite{JSON} data file. The data file contains the height and width of the the generated topology, as well
			as the number of nodes. A \verb|nodes| object consists of as many JSON node-objects as there are nodes. Figure \ref{fig:nodeStruct} illustrates the node structure
			and is an example of how a node with two neighbours will look.
			\begin{figure}[H]
			\begin{minipage}{\linewidth}
			\begin{lstlisting}[language=json]
{
  "mapWidth": 100,
  "mapHeight": 100,
  "nodeCount": 3,
  "nodes": {
    1: {
    "posX": 50,
    "posY": 50, 
    "ssid": "NODE1", 
    "neighbourCount": 2, 
    "neighbours": {
      0: {
        "ssid": NODE2,
        "dbi": -77.23
        },
      1: {
        "ssid": NODE3,
        "dbi": -79.52
        }
      }
    }
  },
...
}
\end{lstlisting}
\end{minipage}
\caption{JSON output structure}
\label{fig:nodeStruct}

\end{figure}
We can run the program in the following way
\begin{verbatim}./GenerateTopology.py -n 200 -w 100 -h 100 --space 10 --dbi 85 \end{verbatim}
Which instructs the program to create a topology with 200 nodes. 
The topology should be 100 by 100 meters large, and there should be at least 10 meters
between each node. The $dbi$ parameter makes sure that only nodes which can be
heard with a $-dBi$-value of $-85$ or larger should be considered neighbours.

The output is a 3.8 MB large file containing the resulting topology-data in JSON.

By writing a simple JavaScript browser application meant to interpret the output, we can
visually represent the nodes on a grid, and the result will look like what can be seen in figure \ref{fig:randtop}

\begin{figure}
\center
\includegraphics[scale=0.4]{Images/randomtopology.png}
\caption{Generated topology with random, uniform distribution}
\label{fig:randtop}
\end{figure}

\section{WiGLE}
WiGLE (Wireless Geographical Logging Engine) \cite{wigle} is a project started in 2001
which purpose is to gather information about wireless networks. The data they have
accumulated in their database is entirely user submitted. Anyone can download an 
Android app  published by WiGLE, and then use the app for wardriving
\footnote{Wardriving is the act of tracking wireless networks using a laptop or a phone,
	and then store the information about each network \cite{Wardriving}.},
	then submit the data to WiGLE's centralized database. All the APs can be viewed on an interactive
	map provided on WiGLE's website. The data can also be accessed through an API call.
	Using their service is entirely free, but the amount of data
	that can be requested is throttled on a day-to-day basis. As they openly support
	research projects, they provided us with an account with a slightly higher daily data
	limit.

	To us this is interesting because we can use the location of APs to
	create more realistic network topologies, and see how well the algorithm 
	performs on these. 


	\subsection{REST API}
	Their REST API provides data presented in JSON, and offers different services,
	such as user profile operations, statistical information and network search.

	We only need to use the networks search part of the API for our purpose. 
	By passing it a request for nodes between two latitudes
	and longitudes, the API responds with the APs in that area.  
	A request will look something like what can be seen in figure \ref{fig:wigReq}
	\begin{figure}
	\begin{lstlisting}[breaklines]
	https://api.wigle.net/api/v2/network/search?first=0&latrange1=37.808469&latrange2=37.746744&longrange1=-122.539232&longrange2=-122.381355
	\end{lstlisting}
	\caption{Example of a Wigle API request}
	\label{fig:wigReq}
	\end{figure}
	The parameters $latrange1$ and $longrange1$ are the coordinates that marks the beginning 
	of the area we are interested in, where $latrange2$ and $longrange2$ marks the end. 
	As WiGLE at most returns information about 100 APs for every query, we need the $start$
	parameter to tell WiGLE at which index offset we want to begin fetching data from.
	A start value of $0$ means we fetch in the range $0-99$, a value of $100$ means in the
	range $100-199$ and so on. The JSON response for a succesful request for an AP,
	can be seen in figure \ref{fig:wigle}.

	\begin{figure}

	\begin{lstlisting}[language=json]
{
	"userfound": false,
	"qos": 0,
	"comment": null,
	"lastupdt": "2015-12-22T17:49:34.000Z",
	"bcninterval": 0,
	"dhcp": "?",
	"lasttime": "2015-12-22T17:49:15.000Z",
	"trilong": 10.82792618,
	"netid": "5C:9E:FF:2B:54:84",
	"freenet": "?",
	"trilat": 62.2816925,
	"name": null,
	"firsttime": "2015-12-22T20:55:01.000Z",
	"type": "infra",
	"ssid": "NETGEAR23",
	"paynet": "?",
	"wep": "2",
	"transid": "20151222-00207",
	"channel": 52
}

\end{lstlisting}
\caption{REST API response with AP data}
\label{fig:wigle}
\end{figure}

We are primarily interested in the properties $trilong$ and $trilat$, which is
the triangulated coordinates of the AP. 

\subsection{Using Wigle data}
WiGLE provides data about the location of access points. However, to be able to
use the data for our group computation, we must translate the global coordinates
to two dimensional coordinates. We can then place each AP on a topology with the
same format as the generated topologies we created in section \ref{simdata}.
This is necessary for two reasons.

The first reason is that creating a group creation program that can operate
on the longitudes and latitudes directly adds more complexity. Both with regards to
group computation and visual representation. 

The second reason is that the WiGLE data does not contain information about
which neighbours each AP can hear, and with what $-dBi$ strengths they are heard.
This will have to be computed like earlier, and by parsing it to the format
we designed in section \ref{simulationrep} we can reuse the code to generate the neighbour lists.

The haversine formula [[ref or explain]] gives us the distance in meters between two coordinates. By calculating
the distane between the latitude startpoint and the latitude endpoint, we can get the size of one
axis in meters. By computing the distance between the longitude start and endpoint we get the size of the
other axis. To place a node correctly in the coordinate system, we simply use the haversine formula on the
origin coordinates to compute the distances between each axis. 

All of this has been implemented in a python program. As input it takes both latitude and longitude start and end coordinates,
    then fetches all nodes within that range and inserts them on a plane. 


